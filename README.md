# the-rust-programming-language

https://doc.rust-jp.rs/book-ja/title-page.html

## 1. 事始め
- !を使用すると、普通の関数ではなくマクロを呼んでいる
- コンパイルと実行は個別のステップ
    - プログラムをコンパイルし、 実行可能ファイルを誰かにあげ、あげた人がRustをインストールしていなくても実行できる
- CargoはRustのビルドシステム兼パッケージマネージャです。 ほとんどのRustaceanはこのツールを使ってRustプロジェクトを管理しています
- `cargo new hello_cargo`
- Rustではコードのパッケージのことをクレートと呼びます
- Cargoでビルドして実行 
    - `cargo build`
    - 実行ファイルを現在のディレクトリではなく、target/debug/hello_cargo（Windowsではtarget/debug/hello_cargo.exe）に作成
- `cargo run` を使うと、コードのコンパイルから、できた実行ファイルの実行までの全体を一つのコマンドで行えます
    - Cargoはファイルが変更されていないことに気づいたので、単にバイナリを実行した
- `cargo check` というコマンドも提供しています。 このコマンドはコードがコンパイルできるか素早くチェックしますが、実行ファイルは生成しません。
- プロジェクトが最終的にリリースできるようになったら、`cargo build --release`を使い、最適化した状態でコンパイルできます

## 2. 数当てゲームのプログラミング
> プログラムは1から100までのランダムな整数を生成します。 そして、プレーヤーに予想（した数字）を入力するように促します。 予想が入力されると、プログラムはその予想が小さすぎるか大きすぎるかを表示します。 予想が当たっているなら、お祝いのメッセージを表示し、ゲームを終了
- ユーザ入力を受け付け、結果を出力するためにはio（入出力）ライブラリをスコープに入れる
- `let apples = 5;`
    - applesという名前の新しい変数を作成し5という値に束縛
    - 変数はデフォルトで不変（immutable）
    - 変数を可変（mutable）にするには、変数名の前にmutをつけます。
- `::new`の行にある::構文はnewがString型の関連関数であることを示しています
    - 関連関数とは、ある型（ここではString）に対して実装される関数のこと
    > let mut guess = String::new();という行は可変変数を作成し、その変数は現時点では新しい空のStringのインスタンスに束縛されているわけです。 ふう！
- ここでioモジュールのstdin関数を呼び出して、ユーザ入力を処理できるようにしましょう。
    - `.read_line`(`&mut guess`)行は、標準入力ハンドルのread_lineメソッドを呼び出し、ユーザからの入力を得ています
    - ead_lineの引数として`&mut guess`を渡し、ユーザ入力をどの文字列に格納するかを指示
    - &は、この引数が参照である
        - これによりコードの複数の部分が同じデータにアクセスしても、そのデータを何度もメモリにコピーしなくて済みます
    - read_lineメソッドは渡された文字列にユーザが入力したものを入れます。 しかし、同時に値（この場合は`io::Result`）も返します。
        - Result型は列挙型
        - 列挙型はenumとも呼ばれ、取りうる値として決まった数の列挙子（variant）を持ちます
        - Resultの列挙子はOkかErr
        - io::ResultインスタンスがErrの値の場合、expectメソッドはプログラムをクラッシュさせ、引数として渡されたメッセージを表示
> あなたのプロジェクトがアプリケーションである場合、Cargo.lockをGitリポジトリにコミットすることが推奨されます。ライブラリの場合は、通常はコミットしません。
- `rand::thread_rng`関数を呼び出して、これから使う、ある特定の乱数生成器を取得
    - `gen_range`メソッドは範囲式を引数にとり、その範囲内の乱数を生成してくれます。 ここで使っている範囲式の種類は開始..終了という形式で、下限値は含みますが上限値は含みません。 そのため、1から100までの数をリクエストするには1..101と指定する必要があります
- `std::cmp::Ordering`
    - Orderingもenumの一つでLess、Greater、Equalという列挙子を持っています
- `cmp`メソッドは二つの値の比較
- match式を使用しており、guessとsecret_numberの値に対してcmpを呼んだ結果返されたOrderingの列挙子に基づき、次の動作を決定
- Stringインスタンスの`trim`メソッドは文字列の先頭と末尾の空白をすべて削除
    - ユーザは予想を入力したあとread_lineの処理を終えるためにEnterキーを押す必要がありますが、これにより文字列に改行文字が追加されます
- `loop`キーワードは無限ループを作成
- match式に切り替えて、エラーによるクラッシュからエラー処理へと移行
    - parseメソッドが文字列から数値への変換に成功したなら、結果の数値を保持するOk値を返します
    - 失敗の場合 Err(_)パターンにはマッチします。 アンダースコアの`_`はすべての値を受け付けます

## 3. 一般的なプログラミングの概念
### 3.1 変数と可変性
- 不変変数xに2回代入できない
    - Rustでは、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保してくれます
    - 変数名の前にmutキーワードを付けることで、可変にできる
- 定数にはmutキーワードは使えません: 定数は標準で不変であるだけでなく、常に不変
    - 定数はletキーワードの代わりに、constキーワードで宣言し、値の型は必ず注釈しなければなりません
    - 定数はどんなスコープでも定義できます。グローバルスコープも含めてです。なので、 いろんなところで使用される可能性のある値を定義するのに役に立ちます
- letを使うことで、 値にちょっとした加工は行えますが、その加工が終わったら、変数は不変
    - 変数の型を可変にすることは許されていない